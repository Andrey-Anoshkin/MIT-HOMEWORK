\documentclass[bachelor, och, coursework]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{tempora}
\usepackage{minted}
\usepackage{xcolor}

\usepackage[colorlinks=true]{hyperref}


\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Лексический и синтаксический анализ выражений}

% Курс
\course{2}

% Группа
\group{251}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
%\studenttitle{Студентов}

% Фамилия, имя, отчество в родительном падеже
\author{Рыданова Никити Сергеевича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{доцент} %должность, степень, звание
\saname{Г.\,Г.\,Наркайтис}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
\patitle{к.\,ф.-м.\,н., доцент}
\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
\practStart{01.07.2016}
\practFinish{14.07.2016}

% Год выполнения отчета
\date{2021}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr

% Раздел "Введение"
\intro

~

\section{Абстрактные синтаксические деревья}
\subsection{Управление памятью на основе регионов}
\subsubsection{Мотивировка}

Текущая реализация абстрактного синтаксического дерева имеет следующие недостатки:

\begin{enumerate}
\item Выделение памяти стандартным методом может значительно фрагментировать оперативную память, затрудняя доступ к ней.
30
\item Любое выделение и удаление памяти требует вмешательства системных
вызовов, что может стать причиной дополнительных издержек во время
работы программы.
\item Программист не имеет возможности ручного управления выделяемой им
памятью
\end{enumerate}

Избавиться от этих недостатков можно используя различные оптимизации. В рамках этой работы воспользуемся управлением памятью на основе, так
называемых, регионов (арен, зон)\cite{wang2002managing}.

Под регионом далее будем понимать непрерывную область памяти, содержащую внутри себя объекты. При запуске программы выделим регион некоторого размера, при необходимости увеличивая его размер в некоторое постоянное
число раз.

Этот подход имеет следующие преимущества:

\begin{enumerate}
\item Элементы располагаются последовательно, в связи с чем минимизируется
фрагментация и упрощается доступ к объектам.
\item Выделение и освобождение памяти выполняется с минимальными издержками.
\item Программисту предоставляется большая свобода для управления выделенной памятью.
\end{enumerate}

\subsubsection{Простроение}

Формально определим требования к системе:

\begin{enumerate}
\item Регион должен представлять из себя некоторый непрерывный участок размера $n$ байт (в начальный момент времени размер равен некоторой начальной величине $n_0$).
\item При обращении к региону он должен предоставить $k$ байт памяти и вернуть
некоторый идентификатор этого участка для последующего обращения.
\item При заполнении региона должна быть возможность увеличить объем доступной памяти в некоторое число раз, которое далее будем называть
коэффициентом увеличения.
\item Должна быть доступна возможность эффективного освобождения всей
выделенной регионом памяти.
\end{enumerate}

Так как выделение нового участка потенциально может сопровождаться изменением адресов объектов, то необходимо организовать доступ к ним независимо
от первоначального адреса. Для этого для каждого объекта будем получать
доступ к нему через некоторый индекс.

Кроме того, коэффициент увеличения должен быть выбран таким образом, чтобы был соблюден баланс между оптимальным объемом выделенной
памяти и частотой системных вызовов.

\subsubsection{Определение структуры}

\setminted{
	style=bw,
	framesep=2mm, 
	baselinestretch=1.2, 
	fontsize=\small, 
	linenos,
	breaklines=true
}

Определим нашу структуру следующим образом:

\begin{minted}{cpp}
typedef struct arena {
	// Указатель на начало региона
	struct node* arena;
	// Размер региона
	unsigned int size;
	// Объем выделенной регионом памяти
	unsigned int allocated;
} arena;
\end{minted}

\subsubsection{Инициализация}

Теперь определим функцию arena\_construct, выполняющую начальную
инициализацию состояния региона:

\begin{minted}{cpp}
int arena_construct (arena* arena) {
	// Начальный размер региона равен некоторой постоянной, равной DEFAULT_ARENA_SIZE
	arena->size = DEFAULT_ARENA_SIZE;
	arena->allocated = 0;
	// Выделим необходимое число памяти
	arena->arena = malloc(sizeof(node) * DEFAULT_ARENA_SIZE);
	// Если выделение прошло неудачно - вернем в качестве кода ошибки отличное от 0 значение.
	if (arena->arena == NULL) {
		return (!0);
	}
	return 0;
}
\end{minted}

\subsubsection{Выделение памяти}

После выделения некоторого объема памяти возможно обращение к ней.
Определим это обращение с помощью функции arena\_allocate:

\begin{minted}{cpp}
int arena_allocate (arena* arena, unsigned int count) {
	// Если места в регионе недостаточно
	if (arena->allocated + count >= arena->size) {
		// Определим новый размер региона
		unsigned int newSize = MULTIPLY_FACTOR * arena->size;
		// Выделим регион большего размера и освободим ранее занятую память
		node* newArena = realloc(arena->arena,
			newSize * sizeof(node));
		if (NULL == newArena) {
			return -1;
		}
		arena->arena = newArena;
		arena->size = newSize;
	}
	// В качестве результата вернем индекс первого свободного участка региона
	unsigned int result = arena->allocated;
	// Сместим индекс на объем выделенной памяти
	arena->allocated += count;
	// Вернем результат
	return result;
}
\end{minted}
Отметим, что наиболее часто значением MULTIPLY\_FACTOR оказывается числа
1.5 и 2. Это позволяет достичь амортизационно константного времени выполнения операции выделения памяти\cite{genmodels}.

\subsubsection{Освобождение выделенной памяти}

Наконец, реализуем освобождение выделенной региону памяти с помощью функции arena\_free

\begin{minted}{cpp}
void arena_free (arena* arena) {
	if (arena->arena != NULL)
	free(arena->arena);
	arena->arena = NULL;
}
\end{minted}

\subsubsection{Модификация абстрактного синтаксического дерева}

Осталось изменить исходный код программы, чтобы обеспечить выделение памяти с помощью полученной нами структуры данных.

Для этого воспользуемся директивой \%param и заявим в качестве параметра переменную типа arena*. В функциях eval, newnum, newast внесем изменения, чтобы обеспечить выделение памятью с помощью написанных ранее
функций.

С полным кодом программы можно ознакомиться в приложении А.

\subsubsection{Сборка проекта}

Теперь проект можно собрать, незначительно изменив Makefile:

\begin{minted}{cpp}
calc.out: calc.l calc.y arena_ast.h
	bison -d calc.y
	flex calc.l
	cc -o $@ calc.tab.c lex.yy.c arena_ast.c arena.c
\end{minted}
и запустить. Результат работы программы представлен на рис. \ref{pic1}

\begin{figure}[h]
\centering
\includegraphics[width=0.7\linewidth]{pics/naivetest.png}
\caption{Демонстрация работы программы}
\label{pic1}
\end{figure}










% Раздел "Заключение"
\conclusion


%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix



\end{document}
